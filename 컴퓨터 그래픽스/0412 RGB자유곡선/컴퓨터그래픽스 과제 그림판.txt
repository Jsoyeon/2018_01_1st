
#include <gl/glut.h>					// openGL을 사용하기 위해서 include 하기
#include <gl/gl.h>
#include <gl/glu.h>

GLint XX, YY, XXX, YYY ;					// 입력받은 마우스 좌표 삽입할 GLint형 변수들
GLfloat A;								// 0.0~1.0 사이의 값으로 표현되기 때문에 위에서 입력받았던 변수 GLfloat형으로 바꿈
GLboolean R = false;					// 마우스 우클릭해서 1번 RED 클릭해 if문 선택되기 전까진 false
GLboolean G = false;					// 마우스 우클릭해서 2번 GREEN 클릭해 if문 선택되기 전까진 false
GLboolean B = false;					// 마우스 우클릭해서 3번 BLUE 클릭해 if문 선택되기 전까진 false

void MyDisplay() {
	
	glColor3f(1.0, 0.0, 0.0);			// 창 오른쪽 위 x:0.8~1.0, y:0.9~1.0 을 차지하는 빨강 사각형 그리기
	glBegin(GL_POLYGON);				// 모델링 시작
	glVertex3f(0.8, 0.9, 0.0);			// 1. 왼쪽 하단 (그리는 순서 지켜야 함!)
	glVertex3f(1.0, 0.9, 0.0);			// 2. 오른쪽 하단
	glVertex3f(1.0, 1.0, 0.0);			// 3. 오른쪽 상단
	glVertex3f(0.8, 1.0, 0.0);			// 4. 왼쪽 상단
	glEnd();							// 모델링 완료

	glColor3f(0.0, 1.0, 0.0);			// 창 오른쪽 위 x:0.8~1.0, y:0.8~0.9 을 차지하는 초록 사각형 그리기
	glBegin(GL_POLYGON);
	glVertex3f(0.8, 0.8, 0.0);			// 1. 왼쪽 하단
	glVertex3f(1.0, 0.8, 0.0);			// 2. 오른쪽 하단
	glVertex3f(1.0, 0.9, 0.0);			// 3. 오른쪽 상단
	glVertex3f(0.8, 0.9, 0.0);			// 4. 왼쪽 상단
	glEnd();

	glColor3f(0.0, 0.0, 1.0);			// 창 오른쪽 위 x:0.8~1.0, y:0.7~0.8 을 차지하는 파랑 사각형 그리기
	glBegin(GL_POLYGON);
	glVertex3f(0.8, 0.7, 0.0);			// 1. 왼쪽 하단
	glVertex3f(1.0, 0.7, 0.0);			// 2. 오른쪽 하단
	glVertex3f(1.0, 0.8, 0.0);			// 3. 오른쪽 상단
	glVertex3f(0.8, 0.8, 0.0);			// 4. 왼쪽 상단
	glEnd();
	
	// MyMouseClick에서 초기화 해준 값 A를 가지고 y좌표값에 따라 색을 구분한다.
	if ((1.0-A) >= 0.9&& (1.0 - A) < 1.0)			// 빨강을 클릭했을 때
		glColor3f(1.0, 0.0, 0.0);					// 빨강(1.0, 0.0, 0.0) 설정
		
	else if ((1.0 - A) >= 0.8&& (1.0 - A) < 0.9)	// 초록을 클릭했을 때
		glColor3f(0.0, 1.0, 0.0);					// 초록(0.0, 1.0, 0.0) 설정
		
	else if ((1.0 - A) >= 0.7&& (1.0 - A) < 0.8)	// 파랑을 클릭했을 때
		glColor3f(0.0, 0.0, 1.0);					// 파랑(0.0, 0.0, 1.0) 설정
		
	else											// 색을 선택하지 않고 그리면 디폴트로 검정색이 나옴.
		glColor3f(0.0, 0.0, 0.0);					// 검정(0.0, 0.0, 0.0) 설정
		
	// 마우스 우클릭 후, 선택한 메뉴에 따라 색이 달라짐.
	if (R)											// 마우스 오른쪽 클릭 후 1. RED 선택 R = true
		glColor3f(1.0, 0.0, 0.0);					// 빨강(1.0, 0.0, 0.0) 설정

	else if (G) 									// 마우스 오른쪽 클릭 후 2. GREEN 선택 G = true
		glColor3f(0.0, 1.0, 0.0);					// 초록(0.0, 1.0, 0.0) 설정

	else if (B) 									// 마우스 오른쪽 클릭 후 3. BLUE 선택 B = true
		glColor3f(0.0, 0.0, 1.0);					// 파랑(0.0, 0.0, 1.0) 설정
		
	glFlush();
}

void MyMouseClick(GLint Button, GLint State, GLint X, GLint Y) {
	if (Button == GLUT_LEFT_BUTTON && State == GLUT_DOWN) {				// 마우스 왼쪽 버튼! & 마우스 버튼이 클릭!(DOWN)
		if ( X/300.0 >= 0.8 && X / 300.0 < 1.0 &&  (300.0-Y)/300.0 >= 0.7 && (300.0-Y)/300.0 <1.0) {
			// 마우스 클릭한 좌표(GLint)를 창 크기인 300.0으로 나누어 GLfloat형으로 바꾸고 해당 값이 x값:0.8~1.0, y값:0.7~1.0 안에 들어가면
			// R,G,B 중 하나의 색을 선택한 것
			A = Y / 300.0;	// x좌표값은 if문의 조건을 통과했기 때문에 영향을 주지 않는다. y값만 A에 저장해 색 구분에 사용.
			R = false;		// 위의 제시된 좌표 값을 클릭했다는 건 색을 선택했다는 것이므로
			G = false;		// 마우스 우클릭하여 선택한 값은
			B = false;		// false로 바꾸어 영향을 미치지 못하게 한다.
		}
		else {				// RGB사각형이 아닌 하얀 공간을 클릭했음.
			XX = X;			// 클릭한 좌표값을 XX, YY에 삽입.
			YY = Y;			
		}
		glutPostRedisplay();	// 이 코드를 안 쓰면 선택한 색깔이 마우스 무브 전까지 적용되지 않는다. MyDisplay()를 재실행해서 색을 세팅하는 과정이 없기 때문.
	}
}

void MyMouseMove(GLint X, GLint Y) {
	XXX = X;				// 마우스가 이동한 X 값은 XXX에, Y 값은 YYY에 삽입.
	YYY = Y;

	glBegin(GL_LINES);		// 색은 MyMouseClick에 있는 glutPostRedisplay();에 의해 MyDisplay()가 실행되어 설정되어 있음. 모델링 시작
	glVertex3f(XX / 300.0, (300 - YY) / 300.0, 0.0);	// 클릭한 좌표를 시작점
	glVertex3f(XXX / 300.0, (300 - YYY) / 300.0, 0.0);	// 움직인 좌표를 끝점으로 하여 선을 그림
	glEnd();				// 모델링 완료
	glutPostRedisplay();	// MyDisplay()를 재실행해서 창에 나타나게 함.

	XX = XXX;	// 계속 마우스의 좌표가 변화하는데, 끝점의 좌표를 시작점으로 넘겨주며 다시 이동하는
	YY = YYY;	// 좌표와 선을 만들어 준다. MyMouseMove() 함수가 마우스 움직이는 동안 계속 실행되기에 끊기지 않고 연결된 그리고 싶은 선이 그려진다.
	
}

void MyMainMenu(int entryID) {	// 마우스 우클릭 후 메뉴 선택하기(색깔)
	if (entryID == 1) {			// 1번 메뉴를 클릭하면
		R = true;				// R은 true, G, B는 false가 된다.
		G = false;
		B = false;
	}
	else if (entryID == 2) {	// 2번 메뉴를 클릭하면
		R = false;				// G는 true, R, B는 false가 된다.
		G = true;
		B = false;
	}
		
	else if (entryID == 3) {	// 3번 메뉴를 클릭하면
		R = false;				// B는 true, R, B는 false가 된다.
		G = false;
		B = true;
	}
	
	glutPostRedisplay();		// MyDisplay()를 재실행하여 if()문을 통해 값의 설정을 변경한다.
}

int main(int argc, char**argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGB);		// RGB 사용
	glutInitWindowSize(300, 300);		// 윈도우(창)크기는 300, 300
	glutInitWindowPosition(0, 0);		// GLUT 화면 좌표계를 사용하는 윈도우. 0, 0은 화면의 좌측 상단임.
	glutCreateWindow("Drawing Name");	// 새 창의 이름은 Drawing Name
	glClearColor(1.0, 1.0, 1.0, 1.0);	// 기본 색
	glMatrixMode(GL_PROJECTION);		// 3D->2D 하는 4*4 행렬을 사용하겠음.
	glLoadIdentity();					// 항등행렬로 초기화!
	glOrtho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);		// 가시부피 값 설정

	GLint MyMainMenuID = glutCreateMenu(MyMainMenu);	// 메뉴의 클릭한 값 선언 및 초기화하기
	glutAddMenuEntry("RED", 1);							//  첫 번째 메뉴는 RED라고 표시함
	glutAddMenuEntry("GREEN", 2);						//  두 번째 메뉴는 GREEN이라고 표시함
	glutAddMenuEntry("BLUE", 3);						//  세 번째 메뉴는 BLUE라고 표시함
	glutAttachMenu(GLUT_RIGHT_BUTTON);					// 마우스 오른쪽 버튼을 클릭하면 메뉴가 추가되어 보임

	glutDisplayFunc(MyDisplay);							// MyDisplay() 콜백 함수 등록 함수
	glutMouseFunc(MyMouseClick);						// MyMouseClick() 콜백 함수 등록 함수
	glutMotionFunc(MyMouseMove);						// MyMouseMove() 콜백 함수 등록 함수

	glutMainLoop();										// 함수가 실행되었는 가를 계속 확인함
	return 0;
}




